#! /usr/bin/env bash

### BEGIN INIT INFO
# Provides:             corfu_server
# Required-Start:       $remote_fs $syslog
# Required-Stop:        $remote_fs $syslog
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
# Short-Description:    Corfu Infrastructure Server
### END INIT INFO

# BEGIN CORFU CONFIG BLOCK
export CORFU_HEAP_SIZE_PERCENT=20
# END CORFU CONFIG BLOCK

set -eE
trap 'echo "Error occurred on line number: $LINENO, in function: $FUNCNAME."' ERR

umask 022

ROLENAME="Corfu Infrastructure Server"
RUNDIR=/var/run/corfu
LOGDIR=/var/log/corfu
DATADIR=/config/corfu
CORFU_USER=corfu
PORT=9000
. /lib/lsb/init-functions

export PATH="${PATH:+$PATH:}/usr/sbin/:usr/bin"

corfu_user_exist=$(id -u $CORFU_USER > /dev/null 2>&1; echo $?)

ensure_dirs () {
    if [ ! -d $RUNDIR ]; then
        mkdir -p $RUNDIR
        chmod 755 $RUNDIR
    fi
    if [ ! -d $LOGDIR ]; then
        mkdir -p $LOGDIR
    fi
}

change_ownership () {
    if [ "$corfu_user_exist" = 0 ]; then
        chown -R $CORFU_USER:$CORFU_USER $RUNDIR
        chown -R $CORFU_USER:$CORFU_USER $LOGDIR
        chown -R $CORFU_USER:$CORFU_USER $DATADIR
    fi
}

set_tanuki_conf () {
    CONVERGED_APP_SYMLINK="/usr/tanuki/conf/corfu-server-wrapper_converged_app_additional.conf"
    ADDITIONAL_CONVERGED_APP_CONF="/usr/tanuki/conf/corfu-server-wrapper_converged_app.conf"
    ADDITIONAL_CONVERGED_APP_CONF_24GB="/usr/tanuki/conf/corfu-server-wrapper_converged_app_24gb.conf"

    NODE_TYPE=`grep node-type /etc/nsx_issue | cut -d\  --fields=2-4`

    # If it's not the converged appliance (manager, policy manager, and controller)
    # or the GM standalone (global-manager) appliance then remove the
    # converged appliance related configuration
    if ( [ "$NODE_TYPE" != "nsx-manager nsx-policy-manager nsx-controller" ] \
      && [ "$NODE_TYPE" != "global-manager" ] ); then
        rm -f "$ADDITIONAL_CONVERGED_APP_CONF"
        rm -f "$ADDITIONAL_CONVERGED_APP_CONF_24GB"
    else
        if [ -L "$CONVERGED_APP_SYMLINK" ]; then
            rm -f "$CONVERGED_APP_SYMLINK"
        fi

        ln -s "$ADDITIONAL_CONVERGED_APP_CONF" "$CONVERGED_APP_SYMLINK"
    fi

    if ( [ "$NODE_TYPE" = "nsx-manager nsx-policy-manager nsx-controller" ] ); then
        SYS_MEM_GB=$(free -g --si | awk '/Mem:/ { total=$2 }  END { print total }')

        if [ $SYS_MEM_GB -le 24 ]; then
            if [ -L "$CONVERGED_APP_SYMLINK" ]; then
                rm -f "$CONVERGED_APP_SYMLINK"
            fi
            ln -s "$ADDITIONAL_CONVERGED_APP_CONF_24GB" "$CONVERGED_APP_SYMLINK"
        fi
    fi
}

ensure_eth0_has_routable_ip_addr () {
    while true; do
        ip addr > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            grep_ip_addr=$(ip addr | grep inet | grep eth0 | grep -E "[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}/[0-9]{1,2}" > /dev/null 2>&1; echo $?)
            if [ ${grep_ip_addr} -eq 0 ]; then
                break
            else
                echo "Interface eth0 does not have a routable network interface. Trying again."
                sleep 1
            fi
        else
            echo "Command ip addr does not have a exit code 0. Trying again"
            sleep 1
        fi
    done
}

ensure_profile_port () {
    op=$1
    set +e
    iptables -w -C INPUT -i eth0 -p tcp -m tcp --dport 54322 --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT 2> /dev/null
    port_stat=$?
    set -e
    if [ $op = "profile" ] && [ ${port_stat} -ne 0 ]; then
        iptables -w -A INPUT -i eth0 -p tcp -m tcp --dport 54322 --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT 2> /dev/null
    elif [ $op = "stop" ] && [ ${port_stat} -eq 0 ]; then
        iptables -w -D INPUT -i eth0 -p tcp -m tcp --dport 54322 --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT 2> /dev/null
    fi
}


#### TRUST GENERATION BEGINS ####
#   copy pasted from cbm init   #
#################################
# modify for entity
CBM_USER=nsx-cbm
ENTITY_NAME=corfu
ENTITY_USER=$CORFU_USER
PASSWORD_LENGTH=32
CBM_BASE_DIR=/config/cluster-manager


# this is the directory structure
# /config/cluster-manager, nsx-cbm, 755
# /config/cluster-manager/entity, nsx-cbm, 755
# /config/cluster-manager/entity/public, nsx-cbm, 750
# /config/cluster-manager/entity/private, entity, 700
generate_key_trust_artifacts () {
    CBM_ENTITY_DIR=$CBM_BASE_DIR/$ENTITY_NAME

    CBM_ENTITY_PUBLIC_DIR=$CBM_ENTITY_DIR/public
    CERT_CER=$CBM_ENTITY_PUBLIC_DIR/certificate.cer
    CERT_PEM=$CBM_ENTITY_PUBLIC_DIR/certificate.pem
    TRUSTSTORE_PASS=$CBM_ENTITY_PUBLIC_DIR/truststore.password
    TRUSTSTORE=$CBM_ENTITY_PUBLIC_DIR/truststore.jks

    CBM_ENTITY_PRIVATE_DIR=$CBM_ENTITY_DIR/private
    KEYSTORE_PASS=$CBM_ENTITY_PRIVATE_DIR/keystore.password
    KEYSTORE=$CBM_ENTITY_PRIVATE_DIR/keystore.jks



    log_daemon_msg "Generating keystore/truststore for ENTITY_NAME=$ENTITY_NAME, ENTITY_USER=$ENTITY_USER."

    if [ -e $CERT_PEM ]; then
        log_daemon_msg "Certificate already exists."
        return
    fi

    # create directories
    mkdir -p $CBM_ENTITY_PUBLIC_DIR
    mkdir -p $CBM_ENTITY_PRIVATE_DIR

    # generate certificate, keystore, truststore
    generate_artifacts

    # modify user and permission
    modify_user_and_permission
}

modify_user_and_permission () {
    chmod 755 $CBM_BASE_DIR
    chown $CBM_USER:$CBM_USER $CBM_BASE_DIR

    chmod 755 $CBM_ENTITY_DIR
    chown $CBM_USER:$CBM_USER $CBM_ENTITY_DIR

    chmod -R 750 $CBM_ENTITY_PUBLIC_DIR
    chmod 640 $CERT_CER
    chmod 640 $CERT_PEM
    chmod 640 $TRUSTSTORE_PASS
    chmod 640 $TRUSTSTORE
    chown -R $CBM_USER:$CBM_USER $CBM_ENTITY_PUBLIC_DIR

    chmod -R 700 $CBM_ENTITY_PRIVATE_DIR
    chmod 600 $KEYSTORE_PASS
    chmod 600 $KEYSTORE
    chown -R $ENTITY_USER:$ENTITY_USER $CBM_ENTITY_PRIVATE_DIR
}

generate_artifacts () {
    #generate keystore password
    KEYSTORE_PASSWORD=`openssl rand -base64 $PASSWORD_LENGTH`
    printf $KEYSTORE_PASSWORD > $KEYSTORE_PASS

    #generate keystore
    keytool -genkey -noprompt -keyalg RSA -alias self -keysize 2048 -validity 36500 -dname "CN=$ENTITY_NAME" \
    -keystore $KEYSTORE -storepass $KEYSTORE_PASSWORD -keypass $KEYSTORE_PASSWORD

    #export certificate
    keytool -noprompt -export -alias self -file $CERT_CER \
    -keystore $KEYSTORE -storepass $KEYSTORE_PASSWORD -keypass $KEYSTORE_PASSWORD
    openssl x509 -inform der -in $CERT_CER -out $CERT_PEM

    #generate trust store password
    TRUSTSTORE_PASSWORD=`openssl rand -base64 $PASSWORD_LENGTH`
    printf $TRUSTSTORE_PASSWORD > $TRUSTSTORE_PASS

    #generate trust store
    keytool -noprompt -import -v -alias self -file $CERT_CER \
    -keystore $TRUSTSTORE -storepass $TRUSTSTORE_PASSWORD
}
#### TRUST GENERATION ENDS ####

prestart () {
    ensure_dirs
    ensure_eth0_has_routable_ip_addr
    ensure_profile_port $1

    log_daemon_msg "Trust generation begins."
    generate_key_trust_artifacts
    log_daemon_msg "Trust generation finished."

    change_ownership
    set_tanuki_conf
}

poststop () {
    ensure_profile_port $1
}

case "$1" in
    prestart)
        prestart start
        ;;
    start|profile)
        log_daemon_msg "Starting $ROLENAME on port $PORT"
        if [ "$(id -u)" = "0" ]; then
            prestart $1
        fi
        /usr/tanuki/bin/corfu-server-wrapper $1
        ;;
    stop)
        log_daemon_msg "Stopping $ROLENAME on port $PORT"
        /usr/tanuki/bin/corfu-server-wrapper $1
        if [ "$(id -u)" = "0" ]; then
            poststop $1
        fi
        ;;
    poststop)
        poststop stop
        ;;
    restart)
        $0 stop
        sleep 1
        $0 start
        ;;
    status)
        /usr/tanuki/bin/corfu-server-wrapper $1
        ;;
    dump)
        /usr/tanuki/bin/corfu-server-wrapper $1
        ;;
    *)
        log_action_msg "Usage $0 {start|profile|stop|restart|status|dump}"
        exit 1
        ;;
esac

exit 0
