package org.corfudb.protocols.service;

import java.util.UUID;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.common.util.CompatibilityVectorUtils;
import org.corfudb.runtime.proto.RpcCommon.UuidMsg;
import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;
import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersionMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;
import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;
import org.corfudb.util.GitRepositoryState;

import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;

/**
 * This class provides methods for creating the Protobuf objects defined
 * in corfu_message.proto. These provide the interface for obtaining headers,
 * as well as the main request and response (Protobuf) messages sent by the
 * client and server.
 */
@Slf4j
public final class CorfuProtocolMessage {
    // Prevent class from being instantiated
    private CorfuProtocolMessage() {}

    /**
     * An Enum wrapper for the boolean field ignore_cluster_id of HeaderMsg.
     */
    public enum ClusterIdCheck {
        CHECK,
        IGNORE
    }

    /**
     * An Enum wrapper for the boolean field ignore_epoch of HeaderMsg.
     */
    public enum EpochCheck {
        CHECK,
        IGNORE
    }

    /**
     * Returns a ProtocolVersionMsg with empty capability_vector and static
     * corfu_source_code_version.
     *
     * @return A ProtocolVersionMsg with empty capability_vector.
     */
    public static ProtocolVersionMsg getDefaultProtocolVersionMsg() {
        return ProtocolVersionMsg.newBuilder()
                .setCorfuSourceCodeVersion(GitRepositoryState.getCorfuSourceCodeVersion())
                .setCapabilityVector(CompatibilityVectorUtils.getCompatibilityVectors())
                .build();
    }

    /**
     * Returns a header containing information common to all service RPCs.
     *
     * @param requestId         the request id, generated by the client
     * @param priority          the priority of the message
     * @param epoch             the epoch of the message
     * @param clusterId         the cluster id
     * @param clientId          the clients own id
     * @param ignoreClusterId   indicates if the message is clusterId aware
     * @param ignoreEpoch       indicates if the message is epoch aware
     * @return                  a HeaderMsg encoding the provided arguments
     */
    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority,
                                         long epoch, UuidMsg clusterId, UuidMsg clientId,
                                         ClusterIdCheck ignoreClusterId, EpochCheck ignoreEpoch) {
        return HeaderMsg.newBuilder()
                .setVersion(getDefaultProtocolVersionMsg())
                .setRequestId(requestId)
                .setPriority(priority)
                .setEpoch(epoch)
                .setClusterId(clusterId)
                .setClientId(clientId)
                .setIgnoreClusterId(ignoreClusterId == ClusterIdCheck.IGNORE)
                .setIgnoreEpoch(ignoreEpoch == EpochCheck.IGNORE)
                .build();
    }

    /**
     * Returns a header containing information common to all service RPCs.
     *
     * @param requestId         the request id, generated by the client
     * @param priority          the priority of the message
     * @param epoch             the epoch of the message
     * @param clusterId         the cluster id
     * @param clientId          the clients own id
     * @param ignoreClusterId   indicates if the message is clusterId aware
     * @param ignoreEpoch       indicates if the message is epoch aware
     * @return                  a HeaderMsg encoding the provided arguments
     */
    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch,
                                         UUID clusterId, UUID clientId,
                                         ClusterIdCheck ignoreClusterId, EpochCheck ignoreEpoch) {
        return getHeaderMsg(requestId, priority, epoch, getUuidMsg(clusterId),
                getUuidMsg(clientId), ignoreClusterId, ignoreEpoch);
    }

    /**
     * Returns a header containing information common to all service RPCs.
     * Used by the server as a convenient way to copy reusable field values.
     *
     * @param header            the original request header
     * @param ignoreClusterId   indicates if the message is clusterId aware
     * @param ignoreEpoch       indicates if the message is epoch aware
     * @return                  a HeaderMsg containing the same field values as the provided
     *                          header, but modifying the ignoreClusterId and ignoreEpoch
     *                          fields with the values provided, and the version info with current
     *                          GitRepositoryState.
     */
    public static HeaderMsg getHeaderMsg(HeaderMsg header, ClusterIdCheck ignoreClusterId,
                                         EpochCheck ignoreEpoch) {
        return HeaderMsg.newBuilder()
                .mergeFrom(header)
                .setVersion(getDefaultProtocolVersionMsg())
                .setIgnoreClusterId(ignoreClusterId == ClusterIdCheck.IGNORE)
                .setIgnoreEpoch(ignoreEpoch == EpochCheck.IGNORE)
                .build();
    }

    /**
     * Returns a header containing information common to all service RPCs.
     * Used by the server as a convenient way to copy reusable field values.
     *
     * @param header    the original request header
     * @return          a HeaderMsg containing the same field values as the provided header, but
     *                  the version info with current GitRepositoryState.
     */
    public static HeaderMsg getHeaderMsg(HeaderMsg header) {
        return HeaderMsg.newBuilder().mergeFrom(header)
                .setVersion(getDefaultProtocolVersionMsg()).build();
    }

    /**
     * Returns a request message sent by the clients.
     *
     * @param header    the request header
     * @param request   the request payload
     * @return          a RequestMsg with the provided header and payload
     */
    public static RequestMsg getRequestMsg(HeaderMsg header, RequestPayloadMsg request) {
        return RequestMsg.newBuilder()
                .setHeader(header)
                .setPayload(request)
                .build();
    }

    /**
     * Returns a response message sent by the server.
     *
     * @param header     the response header
     * @param response   the response payload
     * @return           a ResponseMsg with the provided header and payload
     */
    public static ResponseMsg getResponseMsg(HeaderMsg header, ResponsePayloadMsg response) {
        return ResponseMsg.newBuilder()
                .setHeader(header)
                .setPayload(response)
                .build();
    }

    /**
     * Returns a response message containing an error sent by the server.
     *
     * @param header  the response header
     * @param error   the response error message
     * @return        a ResponseMsg with the provided header and error
     */
    public static ResponseMsg getResponseMsg(HeaderMsg header, ServerErrorMsg error) {
        return ResponseMsg.newBuilder()
                .setHeader(header)
                .setPayload(ResponsePayloadMsg.newBuilder()
                        .setServerError(error)
                        .build())
                .build();
    }
}
