package org.corfudb.runtime;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.FileUtils;
import org.corfudb.protocols.logprotocol.MultiSMREntry;
import org.corfudb.protocols.logprotocol.OpaqueEntry;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.runtime.CorfuStoreMetadata.TableMetadata;
import org.corfudb.runtime.collections.CorfuStore;
import org.corfudb.runtime.collections.TxnContext;
import org.corfudb.runtime.exceptions.BackupRestoreException;
import org.corfudb.runtime.view.CacheOption;
import org.corfudb.runtime.view.TableRegistry;
import org.corfudb.runtime.view.TableRegistry.FullyQualifiedTableName;
import org.corfudb.util.serializer.Serializers;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

import static org.corfudb.runtime.view.TableRegistry.CORFU_SYSTEM_NAMESPACE;

/**
 * Provides Corfu native restore support. Works together with Backup.
 * <p>
 * Restore all tables in the given backup file which is generated by Corfu Backup.
 * <p>
 * Steps:
 * 1. Open the given backup file, obtain a set of backup files for tables
 * 2. Restore tables by writing the OpaqueEntries from table backup files
 */
@Slf4j
public class Restore {

    // The path of backup tar file
    private final String filePath;

    // The path of a temporary directory under which the unpacked table's backup files are stored
    private String restoreTempDirPath;

    // The filename of each table's backup file
    private final List<TableBackupFileName> tableBackupFileNames = new ArrayList<>();

    private final CorfuRuntime rt;

    // The Corfu Store associated with the runtime
    private final CorfuStore corfuStore;

    // Restore mode. Refer to class definition for details
    private final RestoreMode restoreMode;

    // Cache the mapping from table uuid to requires_backup_support in RegistryTable
    private final Map<UUID, Boolean> tableTagged = new HashMap<>();

    // Checkpoint helper used to disable and enable compactor
    private DistributedCheckpointerHelper cpHelper;

    // The namespace to restore. It's only used in PARTIAL_NAMESPACE mode
    private final String namespace;

    // List of tables ignored during clean up and restore
    private static final List<String> IGNORED_CORFU_SYSTEM_TABLES = Arrays.asList(
            CompactorMetadataTables.COMPACTION_MANAGER_TABLE_NAME,
            CompactorMetadataTables.COMPACTION_CONTROLS_TABLE
    );

    /**
     * Unpacked files from backup tar file are stored under RESTORE_TEMP_DIR. They are deleted after restore finishes.
     */
    private static final String RESTORE_TEMP_DIR_PREFIX = "corfu_restore_";

    /***
     * @param filePath      - the path of backup tar file
     * @param runtime       - the runtime which is performing the restore
     * @param restoreMode   - the restore mode can be FULL, PARTIAL, PARTIAL_TAGGED, or PARTIAL_NAMESPACE
     * @param namespace     - the namespace which is being restored; only used in PARTIAL_NAMESPACE mode
     * @throws IOException when failed to create the temp directory
     */
    public Restore(@Nonnull String filePath,
                   @Nonnull CorfuRuntime runtime,
                   @Nonnull RestoreMode restoreMode,
                   @Nullable String namespace) throws IOException {
        this.filePath = filePath;
        this.rt = runtime;
        this.corfuStore = new CorfuStore(runtime);
        this.restoreMode = restoreMode;
        this.namespace = namespace;
    }

    /**
     * Start the restore process
     *
     * @throws IOException exception
     */
    public void start() throws IOException {
        log.info("started corfu restore");
        try {
            // The cleanup() in finally block is not guaranteed to have
            // been run in previous restore if there was OOM
            disableCompaction();
            cleanup();
            openTarFile();
            restore();
        } catch (Exception e) {
            log.error("failed to run restore.", e);
            throw new BackupRestoreException("failed to restore from backup file " + filePath, e);
        } finally {
            enableCompaction();
            cleanup();
        }
        log.info("restore completed");
    }

    @VisibleForTesting
    protected void disableCompaction() throws Exception {
        log.info("Disabling compaction...");
        if (cpHelper == null) {
            try {
                cpHelper = new DistributedCheckpointerHelper(corfuStore);
            } catch (Exception e) {
                log.error("Failed to obtain a DistributedCheckpointerHelper.", e);
                throw e;
            }
        }

        cpHelper.disableCompactionWithWait();
    }

    private void enableCompaction() {
        log.info("Enabling compaction...");
        cpHelper.enableCompaction();
    }

    @VisibleForTesting
    protected void restore() throws IOException {
        if (restoreMode == RestoreMode.FULL) {
            clearAllExceptIgnoredTables();
        } else if (restoreMode == RestoreMode.PARTIAL_NAMESPACE) {
            clearTablesInNamespace(namespace);
        }

        long startTime = System.currentTimeMillis();
        int restoredTableCount = 0;
        for (TableBackupFileName tableBackupFileName : tableBackupFileNames) {
            log.info("start restoring table {}", tableBackupFileName);
            if (tableBackupFileName.namespace.equals(CORFU_SYSTEM_NAMESPACE) &&
                    IGNORED_CORFU_SYSTEM_TABLES.contains(tableBackupFileName.getTableName())) {
                log.info("Skip restoring table {} which is part of IGNORED_TABLES", tableBackupFileName);
                continue;
            }

            // In PARTIAL_TAGGED mode, the RegistryTable is first restored, so the isTableTagged is
            // deduced from the restored RegistryTable.
            if (restoreMode == RestoreMode.PARTIAL_TAGGED && !isTableTagged(tableBackupFileName)) {
                log.info("skip restoring table {} since it doesn't have requires_backup_support tag", tableBackupFileName);
                continue;
            }

            if (restoreMode == RestoreMode.PARTIAL_NAMESPACE &&
                    !Objects.equals(tableBackupFileName.getNamespace(), namespace)) {
                log.info("skip restoring table {} since it's not in namespace {}", tableBackupFileName, namespace);
                continue;
            }

            UUID streamId = tableBackupFileName.getUuid();
            try {
                Path tableBackupPath = Paths.get(restoreTempDirPath).resolve(tableBackupFileName.toString());
                restoreTable(tableBackupPath, streamId);
            } catch (IOException e) {
                log.error("failed to restore table {} from temp file {}", streamId, tableBackupFileName);
                throw e;
            }
            restoredTableCount++;
        }
        long elapsedTime = System.currentTimeMillis() - startTime;
        log.info("successfully restored {} tables out of {} tables from the backup, elapsed time {}ms",
                restoredTableCount, tableBackupFileNames.size(), elapsedTime);
    }

    /**
     * Restore a single table
     *
     * @param filePath   - the path of the temp backup file
     * @param streamId   - the stream ID of the table which is to be restored
     * @throws IOException exception
     */
    private void restoreTable(Path filePath, UUID streamId) throws IOException {
        long startTime = System.currentTimeMillis();

        try (FileInputStream fileInput = new FileInputStream(filePath.toString())) {

            // Clear table before restore
            if (restoreMode == RestoreMode.PARTIAL || restoreMode == RestoreMode.PARTIAL_TAGGED) {
                SMREntry entry = new SMREntry("clear", new Array[0], Serializers.PRIMITIVE);
                nonCachedAppendSMREntries(streamId, entry);
            }

            StreamBatchWriter sbw = new StreamBatchWriter(rt.getParameters().getRestoreBatchSize(),
                    rt.getParameters().getMaxWriteSize(), streamId);
            while (fileInput.available() > 0) {
                OpaqueEntry opaqueEntry = OpaqueEntry.read(fileInput);
                List<SMREntry> smrEntries = opaqueEntry.getEntries().get(streamId);
                if (smrEntries == null || smrEntries.isEmpty()) {
                    continue;
                }

                sbw.batchWrite(smrEntries);
            }
            sbw.shutdown();

            long elapsedTime = System.currentTimeMillis() - startTime;

            log.info("completed restore of table {} with {} SMREntry, total size {} byte(s), elapsed time {}ms",
                    streamId, sbw.getTotalNumSMREntries(), sbw.getTotalWriteSize(), elapsedTime);
        } catch (FileNotFoundException e) {
            log.error("restoreTable can not find file {}", filePath);
            throw e;
        }
    }

    /**
     * Check if the table has requires_backup_tag. Return true if it's RegistryTable.
     */
    private boolean isTableTagged(TableBackupFileName tableBackupFileName) {

        UUID tableUuid = tableBackupFileName.getUuid();
        if (!tableTagged.isEmpty()) {
            // tableTagged is read from RegistryTable which should contain all tables
            Preconditions.checkState(tableTagged.containsKey(tableUuid));
            return tableTagged.get(tableUuid);
        }

        if (Objects.equals(tableBackupFileName.getNamespace(), TableRegistry.CORFU_SYSTEM_NAMESPACE) &&
                Objects.equals(tableBackupFileName.getTableName(), TableRegistry.REGISTRY_TABLE_NAME)) {
            return true;
        }

        // Populate tableTagged map
        // The reason we don't read the tag by getRegistryTable().get(tableName)
        // is that, the tableName extracted from tableBackup is not guaranteed
        // to be a full name. 'TarArchiveOutputStream.LONGFILE_TRUNCATE' is used
        // to generate the backup files which truncates the table names which are
        // too long. The uuid as the first part of the file name is always complete
        // since it has fixed length and is smaller than the truncate limit (100).
        try {
            rt.getTableRegistry()
                    .getRegistryTable()
                    .entryStream()
                    .sequential()
                    .forEach(entry -> {
                        FullyQualifiedTableName fqTableName = FullyQualifiedTableName.build(entry.getKey());
                        UUID streamId = fqTableName.toStreamId().getId();
                        TableMetadata metadata = entry.getValue().getMetadata();
                        Boolean tagged = metadata.hasTableOptions() &&
                                metadata.getTableOptions().getRequiresBackupSupport();

                        log.info("table name is {}, uuid is {}, has backup restore tag {}", fqTableName, streamId, tagged);
                        tableTagged.put(streamId, tagged);
                    });
            log.info("finished caching backup tag information");
        } catch (Exception ex) {
            log.error("failed to populate the tableTagged map!", ex);
            throw ex;
        }

        return tableTagged.get(tableUuid);
    }

    /**
     * Open the backup tar file and save the table backups to tableDir directory
     */
    @VisibleForTesting
    protected void openTarFile() throws IOException {
        this.restoreTempDirPath = Files.createTempDirectory(RESTORE_TEMP_DIR_PREFIX).toString();
        try (FileInputStream fileInput = new FileInputStream(filePath);
             TarArchiveInputStream tarInput = new TarArchiveInputStream(fileInput)) {
            getTablesFromTarFile(tarInput);
        } catch (IOException e) {
            log.error("failed to get tables from tar file {}", filePath);
            throw e;
        }
    }

    private void getTablesFromTarFile(TarArchiveInputStream tarInput) throws IOException {
        int count;
        byte[] buf = new byte[1024];
        TarArchiveEntry entry;
        while ((entry = tarInput.getNextTarEntry()) != null) {
            tableBackupFileNames.add(new TableBackupFileName(entry.getName()));

            String tablePath = restoreTempDirPath + File.separator + entry.getName();
            try (FileOutputStream fos = new FileOutputStream(tablePath)) {
                while ((count = tarInput.read(buf, 0, 1024)) != -1) {
                    fos.write(buf, 0, count);
                }
            }
        }

        // Move the RegistryTable to the beginning of the list
        int index = tableBackupFileNames.stream()
                .filter(fileName -> fileName.getNamespace().equals(TableRegistry.CORFU_SYSTEM_NAMESPACE) &&
                        fileName.getTableName().equals(TableRegistry.REGISTRY_TABLE_NAME))
                .findFirst()
                .map(tableBackupFileNames::indexOf)
                .orElse(-1);

        if (index != -1) {
            Collections.swap(tableBackupFileNames, 0, index);
        }
    }

    /**
     * Delete all temp restore directories under the system temp directory.
     */
    private void cleanup() {
        File tmpdir = new File(System.getProperty("java.io.tmpdir"));
        File[] restoreDirs = tmpdir.listFiles(file -> file.getName().contains(RESTORE_TEMP_DIR_PREFIX));
        if (restoreDirs != null) {
            for (File file : restoreDirs) {
                try {
                    FileUtils.deleteDirectory(file);
                    log.info("removed temporary backup directory {}", file.getAbsolutePath());
                } catch (IOException e) {
                    log.error("failed to delete the temporary backup directory {}", file.getAbsolutePath());
                }
            }
        }
    }

    private void clearAllExceptIgnoredTables() {
        try (TxnContext txn = corfuStore.txn(TableRegistry.CORFU_SYSTEM_NAMESPACE)) {
            corfuStore.getRuntime().getTableRegistry().listTables().forEach(tableName -> {
                FullyQualifiedTableName fqTableName = FullyQualifiedTableName.build(tableName);

                if (fqTableName.isSystemNs() && IGNORED_CORFU_SYSTEM_TABLES.contains(tableName.getTableName())) {
                    return;
                }
                UUID streamId = fqTableName.toStreamId().getId();
                SMREntry entry = new SMREntry("clear", new Array[0], Serializers.PRIMITIVE);
                txn.logUpdate(streamId, entry);
            });

            txn.commit();
        }
        log.info("Cleared all tables.");
    }

    private void clearTablesInNamespace(String namespace) {
        AtomicInteger clearCounter = new AtomicInteger();
        try (TxnContext txn = corfuStore.txn(TableRegistry.CORFU_SYSTEM_NAMESPACE)) {

            corfuStore.getRuntime().getTableRegistry().listTables().forEach(tableName -> {
                if (!tableName.getNamespace().equals(namespace)) {
                    return;
                }

                UUID streamId = FullyQualifiedTableName.streamId(tableName).getId();
                SMREntry entry = new SMREntry("clear", new Array[0], Serializers.PRIMITIVE);
                txn.logUpdate(streamId, entry);
                clearCounter.getAndIncrement();
            });

            txn.commit();
        }
        log.info("Cleared {} tables in namespace {}.", clearCounter, namespace);
    }

    private void nonCachedAppendSMREntries(UUID streamId, SMREntry... smrEntries) {
        MultiSMREntry multiSMREntry = new MultiSMREntry();
        multiSMREntry.addTo(Arrays.asList(smrEntries));
        rt.getStreamsView().append(multiSMREntry, null, CacheOption.WRITE_AROUND, streamId);
    }

    public enum RestoreMode {
        /*
         Restore all tables in the given backup file. Clean up ALL tables before restore.
         */
        FULL,

        /*
         Restore all tables in given backup file. Clean up ONLY tables that are to be restored.
         */
        PARTIAL,

        /*
         Restore tables which have requires_backup_support tag. Clean up ONLY tables that are to be restored.
         This mode supports restoring a subset of (tagged) tables from a full backup file.
         */
        PARTIAL_TAGGED,

        /*
         Restore tables which belong to the given namespace. Clean up ONLY tables that are to be restored.
         This mode supports restoring tables in a certain namespace.
         */
        PARTIAL_NAMESPACE
    }

    class StreamBatchWriter {

        private final int maxBatchSize;
        private final int maxWriteSize;
        private final UUID streamId;

        @Getter
        private int totalNumSMREntries = 0;
        @Getter
        private int totalWriteSize = 0;

        private final List<SMREntry> buffer = new ArrayList<>();
        private int bufferWriteSize = 0;

        StreamBatchWriter(int maxBatchSize, int maxWriteSize, UUID streamId) {
            this.maxBatchSize = maxBatchSize;
            this.maxWriteSize = maxWriteSize;
            this.streamId = streamId;
        }

        public void batchWrite(List<SMREntry> smrEntries) {
            if (smrEntries.isEmpty()) {
                return;
            }

            for (SMREntry smrEntry : smrEntries) {
                if (buffer.size() == maxBatchSize || bufferWriteSize + smrEntry.getSerializedSize() > maxWriteSize) {
                    flushBuffer();
                }
                buffer.add(smrEntry);
                bufferWriteSize += smrEntry.getSerializedSize();
            }
        }

        public void shutdown() {
            flushBuffer();
        }

        private void flushBuffer() {
            totalNumSMREntries += buffer.size();
            totalWriteSize += bufferWriteSize;

            nonCachedAppendSMREntries(streamId, buffer.toArray(new SMREntry[0]));

            bufferWriteSize = 0;
            buffer.clear();
        }

    }

    static class TableBackupFileName {

        @Getter
        private final UUID uuid;

        @Getter
        private final String namespace;

        @Getter
        private final String tableName;

        public TableBackupFileName(String backupFileName) {
            // backup file name format: uuid.namespace$tableName
            this.uuid = UUID.fromString(backupFileName.substring(0, backupFileName.indexOf(".")));
            String[] strings = backupFileName.substring(backupFileName.indexOf(".")+1).split("\\$");
            this.namespace = strings[0];
            this.tableName = strings[1];
        }

        @Override
        public String toString() {
            return uuid.toString() + "." + FullyQualifiedTableName.build(namespace, tableName).toFqdn();
        }
    }
}
