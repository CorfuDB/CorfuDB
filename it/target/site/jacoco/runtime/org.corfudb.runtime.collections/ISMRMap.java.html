<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ISMRMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">universe</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.collections</a> &gt; <span class="el_source">ISMRMap.java</span></div><h1>ISMRMap.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.collections;

import com.google.common.collect.ImmutableMap;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import org.corfudb.annotations.Accessor;
import org.corfudb.annotations.ConflictParameter;
import org.corfudb.annotations.Mutator;
import org.corfudb.annotations.MutatorAccessor;

/**
 * Created by mwei on 1/9/16.
 */
@SuppressWarnings(&quot;checkstyle:abbreviation&quot;)
public interface ISMRMap&lt;K, V&gt; extends Map&lt;K, V&gt;, ISMRObject {

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    int size();

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with any modification to
     * the map, since the size of the map could be potentially changed.
     */
    @Accessor
    @Override
    boolean isEmpty();

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    boolean containsKey(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with any modification to
     * the map, since the presence of values could be potentially changed.
     */
    @Accessor
    @Override
    boolean containsValue(Object value);

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with any operation on the
     * given key.
     */
    @Accessor
    @Override
    V get(@ConflictParameter Object key);

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name = &quot;put&quot;, undoFunction = &quot;undoPut&quot;, undoRecordFunction = &quot;undoPutRecord&quot;)
    @Override
    V put(@ConflictParameter K key, V value);


    /**
     * This operation behaves like a put operation, but does not
     * return the previous value, and does not result in a read
     * of the map.
     *
     * &lt;p&gt;Calling this operation produces the same put record as calling
     * &quot;put&quot; directly. However, the runtime will not try to sync
     * the object to obtain an upcall.
     *
     * &lt;p&gt;Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @Mutator(name = &quot;put&quot;, noUpcall = true)
    default void blindPut(@ConflictParameter K key, V value) {
<span class="nc" id="L93">        put(key, value);</span>
<span class="nc" id="L94">    }</span>

    /** Generate an undo record for a put, given the previous state of the map
     * and the parameters to the put call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the put call
     * @param value             The value from the put call. This is not
     *                          needed to generate an undo record.
     * @return                  An undo record, which for a put is the
     *                          previous value in the map.
     */
    default V undoPutRecord(ISMRMap&lt;K,V&gt; previousState, K key, V value) {
<span class="nc" id="L107">        return previousState.get(key);</span>
    }

    /** Undo a put, given the current state of the map, an undo record
     * and the arguments to the put command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoPutRecord
     * @param key           The key of the put to undo
     * @param value         The value of the put to undo, which is not
     *                      needed.
     */
    default void undoPut(ISMRMap&lt;K,V&gt; map, V undoRecord, K key, V value) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (undoRecord == null) {</span>
<span class="nc" id="L121">            map.remove(key);</span>
        } else {
<span class="nc" id="L123">            map.put(key, undoRecord);</span>
        }
<span class="nc" id="L125">    }</span>

    /**
     * {@jnheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation produces a conflict with any other
     * operation on the given key.
     */
    @MutatorAccessor(name = &quot;remove&quot;, undoFunction = &quot;undoRemove&quot;,
            undoRecordFunction = &quot;undoRemoveRecord&quot;)
    @Override
    V remove(@ConflictParameter Object key);

    /** Generate an undo record for a remove, given the previous state of the map
     * and the parameters to the remove call.
     *
     * @param previousState     The previous state of the map
     * @param key               The key from the remove call
     * @return                  An undo record, which for a remove is the
     *                          previous value in the map.
     */
    default V undoRemoveRecord(ISMRMap&lt;K,V&gt; previousState, K key) {
<span class="nc" id="L147">        return previousState.get(key);</span>
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoRemove(ISMRMap&lt;K,V&gt; map, V undoRecord, K key) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (undoRecord == null) {</span>
<span class="nc" id="L158">            map.remove(key);</span>
        } else {
<span class="nc" id="L160">            map.put(key, undoRecord);</span>
        }
<span class="nc" id="L162">    }</span>

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts on any keys that are in the map given.
     */
    @Mutator(name = &quot;putAll&quot;, undoFunction = &quot;undoPutAll&quot;,
            undoRecordFunction = &quot;undoPutAllRecord&quot;,
            conflictParameterFunction = &quot;putAllConflictFunction&quot;)
    @Override
    void putAll(Map&lt;? extends K, ? extends V&gt; m);


    /** Generate the conflict parameters for putAll, given the arguments to the
     * putAll operation.
     * @param m                 The map for the putAll operation.
     * @return                  An array of conflict parameters, which are the
     *                          hash codes of the keys given.
     */
    default Object[] putAllConflictFunction(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L183">        return m.keySet().stream()</span>
<span class="nc" id="L184">                .map(Object::hashCode)</span>
<span class="nc" id="L185">                .toArray(Object[]::new);</span>
    }

<span class="nc" id="L188">    enum UndoNullable {</span>
<span class="nc" id="L189">        NULL;</span>
    }

    /** Generate an undo record for putAll, given the previous state of the map
     * and the parameters to the putAll call.
     *
     * @param previousState     The previous state of the map
     * @param m                 The map from the putAll call
     * @return                  An undo record, which for a putAll is all the
     *                          previous entries in the map.
     */
    default Map&lt;K,V&gt; undoPutAllRecord(ISMRMap&lt;K,V&gt; previousState, Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L201">        ImmutableMap.Builder&lt;K,V&gt; builder = ImmutableMap.builder();</span>
<span class="nc" id="L202">        m.keySet().forEach(k -&gt; builder.put(k,</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                (previousState.get(k) == null ? (V) UndoNullable.NULL : previousState.get(k))));</span>
<span class="nc" id="L204">        return builder.build();</span>
    }

    /** Undo a remove, given the current state of the map, an undo record
     * and the arguments to the remove command to undo.
     *
     * @param map           The state of the map after the put to undo
     * @param undoRecord    The undo record generated by undoRemoveRecord
     */
    default void undoPutAll(ISMRMap&lt;K,V&gt; map, Map&lt;K,V&gt; undoRecord,
                            Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L215">        undoRecord.entrySet().forEach(e -&gt; {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (e.getValue() == UndoNullable.NULL) {</span>
<span class="nc" id="L217">                map.remove(e.getKey());</span>
            } else {
<span class="nc" id="L219">                map.put(e.getKey(), e.getValue());</span>
            }
<span class="nc" id="L221">        }</span>
        );
<span class="nc" id="L223">    }</span>


    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Conflicts: this operation conflicts with the entire map, since it drops
     * all mappings which are present.
     */
    @Mutator(name = &quot;clear&quot;, reset = true)
    @Override
    void clear();

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;This function currently does not return a view like the java.util implementation,
     * and changes to the keySet will *not* be reflected in the map.
     *
     * &lt;p&gt;Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set&lt;K&gt; keySet();

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;This function currently does not return a view like the java.util implementation,
     * and changes to the values will *not* be reflected in the map.
     *
     * &lt;p&gt;Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Collection&lt;V&gt; values();

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;This function currently does not return a view like the java.util implementation,
     * and changes to the entrySet will *not* be reflected in the map.
     *
     * &lt;p&gt;Conflicts: This operation currently conflicts with any modification
     * to the map.
     */
    @Accessor
    @Override
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>