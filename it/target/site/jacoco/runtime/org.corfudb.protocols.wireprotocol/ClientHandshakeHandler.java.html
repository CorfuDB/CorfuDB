<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientHandshakeHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">universe</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.protocols.wireprotocol</a> &gt; <span class="el_source">ClientHandshakeHandler.java</span></div><h1>ClientHandshakeHandler.java</h1><pre class="source lang-java linenums">package org.corfudb.protocols.wireprotocol;

import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.timeout.ReadTimeoutException;
import io.netty.handler.timeout.ReadTimeoutHandler;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import java.util.LinkedList;
import java.util.Queue;
import java.util.UUID;

/**
 * The ClientHandshakeHandler initiates the handshake upon socket connection.
 *
 * - Once the client connects to the server, it sends a handshake message that contains:
 *         its own id and the (asserted) server's node id.
 * - The server validates and replies with its node id and current version of Corfu.
 * - If validation is correct on both sides, message exchange is initiated between client-server,
 * otherwise, the handshake times out, and either server or client close the connection.
 *
 * Created by amartinezman on 12/8/17.
 */
<span class="nc" id="L26">@Slf4j</span>
public class ClientHandshakeHandler extends ChannelDuplexHandler {

    private final UUID clientId;
    private final UUID nodeId;
    private final int handshakeTimeout;
    private final HandshakeState handshakeState;
<span class="nc" id="L33">    private final Queue&lt;CorfuMsg&gt; messages = new LinkedList&lt;&gt;();</span>
    private static final String READ_TIMEOUT_HANDLER = &quot;readTimeoutHandler&quot;;

    /** Events that the handshaker sends to downstream handlers.
     *
     */
<span class="nc" id="L39">    public enum ClientHandshakeEvent {</span>
<span class="nc" id="L40">        CONNECTED,  /* Connection succeeded. */</span>
<span class="nc" id="L41">        FAILED      /* Handshake failed. */</span>
    }

    /**
     * Creates a new ClientHandshakeHandler which will handle the handshake between the
     * current client and a remote server.
     *
     * @param clientId Current Client Identifier.
     * @param serverId Remote Server Identifier to connect to.
     */
<span class="nc bnc" id="L51" title="All 2 branches missed.">    public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handshakeTimeout) {</span>
<span class="nc" id="L52">        this.clientId = clientId;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (serverId == null) {</span>
            // A null identifier, indicates node ID matching is not required. Send a default
            // (all 0's) UUID to Server, to ignore matching stage during handshake
<span class="nc" id="L56">            this.nodeId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</span>
        } else {
<span class="nc" id="L58">            this.nodeId = serverId;</span>
        }
<span class="nc" id="L60">        this.handshakeTimeout = handshakeTimeout;</span>
<span class="nc" id="L61">        this.handshakeState = new HandshakeState();</span>
<span class="nc" id="L62">    }</span>

    /**
     * Read data from the Channel.
     *
     * @param ctx channel handler context
     * @param m object received in inbound buffer
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object m)
        throws Exception {

<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (this.handshakeState.failed()) {</span>
            // if handshake has already failed, return
<span class="nc" id="L77">            return;</span>
        }

<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (this.handshakeState.completed()) {</span>
            // If handshake completed successfully, but still a message came through this handler,
            // send on to the next handler in order to avoid message loss.
<span class="nc" id="L83">            super.channelRead(ctx, m);</span>
<span class="nc" id="L84">            return;</span>
        }

        CorfuPayloadMsg&lt;HandshakeResponse&gt; handshakeResponse;

        try {
<span class="nc" id="L90">            handshakeResponse = (CorfuPayloadMsg&lt;HandshakeResponse&gt;) m;</span>
<span class="nc" id="L91">            log.info(&quot;channelRead: Handshake Response received. Removing {} from pipeline.&quot;,</span>
                    READ_TIMEOUT_HANDLER);
            // Remove the handler from the pipeline. Also remove the reference of the context from
            // the handler so that it does not disconnect the channel.
<span class="nc" id="L95">            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);</span>
<span class="nc" id="L96">        } catch (ClassCastException e) {</span>
<span class="nc" id="L97">            log.warn(&quot;channelRead: Non-handshake message received by handshake handler. &quot; +</span>
                    &quot;Send upstream only if handshake succeeded.&quot;, e);
<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (this.handshakeState.completed()) {</span>
                // Only send upstream if handshake is complete.
<span class="nc" id="L101">                super.channelRead(ctx, m);</span>
            } else {
                // Otherwise, drop message.
                try {
<span class="nc" id="L105">                    CorfuMsg msg = (CorfuMsg) m;</span>
<span class="nc" id="L106">                    log.debug(&quot;channelRead: Dropping message: {}&quot;, msg.getMsgType().name());</span>
<span class="nc" id="L107">                } catch (Exception ex) {</span>
<span class="nc" id="L108">                    log.error(&quot;channelRead: Message received is not a valid CorfuMsg type.&quot;);</span>
<span class="nc" id="L109">                }</span>
            }
<span class="nc" id="L111">            return;</span>
<span class="nc" id="L112">        }</span>

<span class="nc" id="L114">        UUID serverId = handshakeResponse.getPayload().getServerId();</span>
<span class="nc" id="L115">        String corfuVersion = handshakeResponse.getPayload().getCorfuVersion();</span>

        // Validate handshake, but first verify if node identifier is set to default (all 0's)
        // which indicates node id matching is not required.
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (this.nodeId.equals(UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;))) {</span>
<span class="nc" id="L120">            log.info(&quot;channelRead: node id matching is not requested by client.&quot;);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        } else if (!this.nodeId.equals(serverId)) {</span>
            // Validation failed, client opened a socket to server with id
            // 'nodeId', instead server's id is 'serverId'
<span class="nc" id="L124">            log.error(&quot;channelRead: Handshake validation failed. Server node id mismatch.&quot;);</span>
<span class="nc" id="L125">            log.debug(&quot;channelRead: Client opened socket to server [{}] instead, connected to: [{}]&quot;,</span>
                    this.nodeId, serverId);
<span class="nc" id="L127">            this.fireHandshakeFailed(ctx);</span>
<span class="nc" id="L128">            return;</span>
        }

<span class="nc" id="L131">        log.info(&quot;channelRead: Handshake succeeded. Server Corfu Version: [{}]&quot;, corfuVersion);</span>
<span class="nc" id="L132">        log.debug(&quot;channelRead: There are [{}] messages in queue to be flushed.&quot;, this.messages.size());</span>
        // Flush messages in queue
<span class="nc bnc" id="L134" title="All 2 branches missed.">        while (!messages.isEmpty()) {</span>
<span class="nc" id="L135">            ctx.writeAndFlush(messages.poll());</span>
        }

        // Remove this handler from the pipeline; handshake is completed.
<span class="nc" id="L139">        log.info(&quot;channelRead: Removing handshake handler from pipeline.&quot;);</span>
<span class="nc" id="L140">        ctx.pipeline().remove(this);</span>
<span class="nc" id="L141">        this.fireHandshakeSucceeded(ctx);</span>
<span class="nc" id="L142">    }</span>

    /**
     * Channel event that is triggered when a new connected channel is created.
     *
     * @param ctx channel handler context
     * @throws Exception
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx)
        throws Exception {
<span class="nc" id="L153">        log.info(&quot;channelActive: Outgoing connection established to: {}&quot;, ctx.channel().remoteAddress());</span>

        // Write the handshake &amp; add a timeout listener.
<span class="nc" id="L156">        CorfuMsg handshake = CorfuMsgType.HANDSHAKE_INITIATE</span>
<span class="nc" id="L157">            .payloadMsg(new HandshakeMsg(this.clientId, this.nodeId));</span>

<span class="nc" id="L159">        log.debug(&quot;channelActive: Initiate handshake. Send handshake message.&quot;);</span>
<span class="nc" id="L160">        ctx.writeAndFlush(handshake);</span>
<span class="nc" id="L161">        log.debug(&quot;channelActive: Add {} to channel pipeline.&quot;, READ_TIMEOUT_HANDLER);</span>
<span class="nc" id="L162">        ctx.pipeline().addBefore(ctx.name(), READ_TIMEOUT_HANDLER, new ReadTimeoutHandler(this.handshakeTimeout));</span>
<span class="nc" id="L163">    }</span>

    /**
     * Channel event that is triggered when the channel is closed.
     *
     * @param ctx channel handler context
     * @throws Exception
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L173">        log.debug(&quot;channelInactive: Channel closed.&quot;);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (!this.handshakeState.completed()) {</span>
<span class="nc" id="L175">            this.fireHandshakeFailed(ctx);</span>
        }
<span class="nc" id="L177">    }</span>

    /**
     * Channel event that is triggered when an exception is caught.
     *
     * @param ctx channel handler context
     * @param cause exception cause
     * @throws Exception
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx,
        java.lang.Throwable cause) throws Exception {
<span class="nc" id="L189">        log.error(&quot;exceptionCaught: Exception {} caught.&quot;, cause.getClass().getSimpleName(), cause);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (cause instanceof ReadTimeoutException) {</span>
            // Handshake has failed or completed. If none is True, handshake timed out.
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (this.handshakeState.failed()) {</span>
<span class="nc" id="L193">                log.debug(&quot;exceptionCaught: Handshake timeout checker: already failed.&quot;);</span>
<span class="nc" id="L194">                return;</span>
            }

<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (!this.handshakeState.completed()) {</span>
                // If handshake did not complete nor failed, it timed out.
                // Force failure.
<span class="nc" id="L200">                log.error(&quot;exceptionCaught: Handshake timeout checker: timed out.&quot; +</span>
                    &quot; Close Connection.&quot;);
<span class="nc" id="L202">                this.handshakeState.set(true, false);</span>
            } else {
                // Handshake completed successfully,
<span class="nc" id="L205">                log.debug(&quot;exceptionCaught: Handshake timeout checker: discarded &quot; +</span>
                    &quot;(handshake OK)&quot;);
            }
        }
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (ctx.channel().isOpen()) {</span>
<span class="nc" id="L210">            ctx.channel().close();</span>
        } else {
<span class="nc" id="L212">            this.fireHandshakeFailed(ctx);</span>
        }
<span class="nc" id="L214">    }</span>

    /**
     * Channel event that is triggered when an outbound handler attempts to write into the channel.
     *
     * @param ctx channel handler context
     * @param msg message written into channel
     * @param promise channel promise
     * @throws Exception
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
        throws Exception {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (this.handshakeState.failed()) {</span>
<span class="nc" id="L228">            return;</span>
        }

        // If the handshake hasn't failed but completed meanwhile and
        // messages still passed through this handler, then forward
        // them downwards.
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (this.handshakeState.completed()) {</span>
<span class="nc" id="L235">            super.write(ctx, msg, promise);</span>
        } else {
            // Otherwise, queue messages in order until the handshake
            // completes.
<span class="nc" id="L239">            this.messages.offer((CorfuMsg) msg);</span>
        }
<span class="nc" id="L241">    }</span>

    /**
     * Signal handshake as failed.
     *
     * @param ctx channel handler context
     */
    private void fireHandshakeFailed(ChannelHandlerContext ctx) {
<span class="nc" id="L249">        this.handshakeState.set(true, true);</span>
<span class="nc" id="L250">        log.error(&quot;fireHandshakeFailed: Handshake Failed. Close Channel.&quot;);</span>
        // Let downstream handlers know the handshake failed
<span class="nc" id="L252">        ctx.fireUserEventTriggered(ClientHandshakeEvent.FAILED);</span>
<span class="nc" id="L253">        ctx.channel().close();</span>
<span class="nc" id="L254">    }</span>

    /**
     * Signal handshake as succeeded.
     */
    private void fireHandshakeSucceeded(ChannelHandlerContext ctx) {
<span class="nc" id="L260">        this.handshakeState.set(false, true);</span>
        // Let downstream handlers know the handshake succeeded.
<span class="nc" id="L262">        ctx.fireUserEventTriggered(ClientHandshakeEvent.CONNECTED);</span>
<span class="nc" id="L263">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>