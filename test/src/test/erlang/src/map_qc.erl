-module(map_qc).

%% -------------------------------------------------------------------
%%
%% Copyright (c) 2016 VMware, Inc. All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc QuickCheck model for linearizability verification of `SMRMap' and `FGMap'
%%
%% See the README.md file in the parent directory for instructions for
%% compiling & running.
%%
%% The Java `SMRMap' and `FGMap' objects claim to implement strict
%% linearizable behavior by all concurrent access interleavings by any
%% number of concurrent actors.  QuickCheck is not capable of formally
%% verifying all executions by an arbitrary number of actors.
%% However, QuickCheck is capable of producing a random sequence of
%% object method calls by a modest number of concurrent actors (up
%% approximately seven) and verifying that a single execution of those
%% calls concurrently does indeed have an equivalent linearizable
%% execution.
%%
%% This module provides two testable QuickCheck properties:
%%
%% 1. `prop()', which generates random method calls for a
%%    single actor.
%%
%% 2. `prop_parallel()', which generates random method calls
%%    for multiple actors.
%%
%% == Model Implementation ==
%%
%% Our model is based on a simple in-memory key-value dictionary,
%% equivalent to a Python dictionary or a Java `HashMap': an Erlang
%% `orddict' dictionary.  Key=string, value=string.  Each Java method
%% is mapped onto equivalent `orddict' functions.
%%
%% The first command in any command sequence is the `reset()' command.
%% This function deletes all state in the server's `Sequencer' and
%% `LogUnit' objects, in memory and on disk, and then simulates a
%% reboot of those objects.  The result is an empty Corfu stream and
%% therefore an empty `SMRMap'/`FGMap' at the beginning of each test.
%%
%% The commands generated by this model are weighted via the
%% QuickCheck `frequency()'.  See the `command()' function below for
%% details.  In general, mutating commands (e.g., `put()') are
%% weighted more heavily than read-only commands (e.g., `isEmpty()').
%%
%% Using a different QuickCheck function, the generators for key &
%% value strings, `gen_key()' and `gen_val()', respectively, will
%% choose certain strings more frequently than others.  This design
%% choice is intentional.  Given QC's randomness, we wish to constrain
%% the randomness to create frequent collisions on the same key (or
%% value).
%%
%% Both keys & values are strings, rather than arbitrary binary blobs.
%% Keys are a single byte, and values are limited to roughly 50 bytes.
%% This model is not intended to explore data variation scenarios
%% (e.g. non-printable character data), buffer overflows, or other
%% data size boundary conditions.  QuickCheck can be used for those
%% scenarios, but not in this module.
%%
%% == Actor & Concurrency Details ==
%%
%% QuickCheck is responsible for creating multiple threads of
%% execution for executing concurrent test cases.  When testing the
%% `prop_parallel()' property, QuickCheck will generate a series of
%% commands with this shape:
%%
%% 1. A series of commands that will be executed sequentially by a
%%    single Erlang process/thread/actor.
%%
%% 2. A list of lists of subsequent commands, each list will be executed
%%    concurrently by concurrent Erlang processes/threads/actors.
%%
%% The concurrency at the Erlang & QuickCheck levels can guarantee
%% scheduling control guarantees on neither the Erlang side nor the
%% Java side.
%%
%% All commands generated by this module include a `mailbox' argument;
%% this argument is the 1st arg for each test command invocation.
%% Each mailbox has a dedicated Pthread on the Java side for executing
%% commands that are requested by QuickCheck.  Therefore, it is
%% possible for different concurrent Erlang processes to send method
%% call requests to Java by requesting different mailboxes and
%% therefore get truly concurrent execution on the Java side (within
%% the limits of Pthread scheduling in the hardware & OS environment).
%% If concurrent QuickCheck processes send method call requests to the
%% same mailbox on the Java side, then the Java method invocations
%% will be executed sequentially by a single Pthread.
%% (See also the bottom of ../README.md for a description of the
%% implementation of the Erlang <-> Java communication protocol used
%% by this module.)
%%
%% On the Java side, each mailbox Pthread instantiates an independent
%% `CorfuRuntime' object and therefore independent copies of the
%% `SMRMap' and `FGMap' objects that are under test.
%%
%% == Limitations ==
%%
%% All commands generated by this module include an `endpoint'
%% argument; this argument is the 2nd arg for each test command
%% invocation.  This allows test models to operate on the same Corfu
%% data by communicating with different mailboxes on different Corfu
%% servers in a single cluster.  However, today's implementation of
%% the test model assumes that the cluster size is exactly one server.
%%
%% Similarly, the mailbox naming convention allows test commands to
%% invoke methods on multiple JVMs could execute client-only code.
%% However, today's implementation assumes that the Corfu
%% client/`CorfuRuntime' is executing within the same JVM as the Corfu
%% server under test.
%%
%% The QuickCheck implementation that we use, the open source PropEr
%% project, will create relatively short sequences of commands, where
%% "relative" means relative to a test that runs for hours or days.
%% Longer tests can be created via overriding QC's built-in data
%% generators, at the risk of making QC unable to shrink a failing
%% test case to a smaller-but-still-failing test case.  At the end of
%% a successful test run, QuickCheck will output a summary of command
%% sequence lengths and the mix of individual operations in each
%% sequence.  For example:
%%
%% 35% {map_qc,put,6}
%% 9% {map_qc,get,5}
%% 7% {map_qc,remove,5}
%% 6% {map_qc,containsValue,5}
%% 6% {map_qc,keySet,4}
%% 5% {map_qc,values,4}
%% 5% {map_qc,reset,2}
%% 5% {map_qc,entrySet,4}
%% 4% {map_qc,isEmpty,4}
%% 4% {map_qc,containsKey,5}
%% 4% {map_qc,clear,4}
%% 4% {map_qc,size,4}
%%
%% cmds_length
%% minimum: 4
%% average: 19.5
%% maximum: 45
%%
%% PropEr's implementation of linearizable execution path discovery
%% has a combinatorial explosion problem.  To limit the size of the
%% explosion, PropEr's generation of each parallel command sequence is
%% limited to approximately 10 or fewer commands.
%%
%% The protocol used to communicate between Erlang and Java VMs that
%% prevents the Erlang side from determining if a set of values
%% contains a zero-length string.  This prevents us from some
%% validation of value string of length zero.  We also do not test the
%% `putAll()' method, due to a similar protocol limitation.

-include("qc_java.hrl").

-define(TIMEOUT, 12*1000).

-compile(export_all).

-record(state, {
          map_type = smrmap :: 'smrmap' | 'fgmap',
          replication_type :: 'chain_replication' | 'replex',
          endpoint :: string(),
          reg_names :: list(),
          reset_p = false :: boolean(),
          stream :: non_neg_integer(),
          d=orddict:new() :: orddict:orddict()
         }).

-record(exec, {step,func,args}).                % exec step: {set,{var,_},...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

gen_mbox(#state{endpoint=Endpoint, reg_names=RegNames}) ->
    noshrink( ?LET(RegName, oneof(RegNames),
                   {RegName, qc_java:endpoint2nodename(Endpoint)} )).

gen_key() ->
    oneof([[choose($a, $b)],                     % make it a list
           [choose($a, $z)]]).                   % make it a list

gen_val() ->
    oneof(["",
           "Hello-world!",                      % no spaces or commas!
           "Another-value",
           ?LET(L, choose(0, 50),
                vector(L, choose($a, $z)))]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

initial_state() ->
    initial_state(chain_replication, smrmap,
                  qc_java:local_mboxes(), qc_java:local_endpoint()).

initial_state(ReplType, MapType, Mboxes, Endpoint) ->
    %% This model restricts itself to always using the same streamID.
    %% Future expansion could exercise multiple streams
    %% simultaneously, e.g., using multiple dictionaries to maintain
    %% per-stream state.
    #state{replication_type=ReplType,
           map_type=MapType,
           endpoint=Endpoint, reg_names=Mboxes,
           stream=42}.

precondition(S, {call,_,reset,_}) ->
    not S#state.reset_p;
precondition(S, _Call) ->
    S#state.reset_p.

command(S=#state{replication_type=ReplType, endpoint=Endpoint, reset_p=false}) ->
    {call, ?MODULE, reset, [gen_mbox(S), Endpoint, ReplType]};
command(S=#state{map_type=MapType,
                 endpoint=Endpoint, stream=Stream, reset_p=true}) ->
    frequency(
      [
       {20, {call, ?MODULE, put, [gen_mbox(S), Endpoint, Stream, MapType,
                                  gen_key(), gen_val()]}},
       { 5, {call, ?MODULE, get, [gen_mbox(S), Endpoint, Stream, MapType,
                                  gen_key()]}},
       { 3, {call, ?MODULE, size, [gen_mbox(S), Endpoint, Stream, MapType]}},
       { 3, {call, ?MODULE, isEmpty, [gen_mbox(S), Endpoint, Stream, MapType]}},
       { 3, {call, ?MODULE, containsKey, [gen_mbox(S), Endpoint, Stream, MapType,
                                          gen_key()]}},
       %% Our ASCII-oriented protocol can't tell the difference
       %% between an arity 0 function and an arity 1 function with
       %% an argument of length 0.  Avoid the problem by always generating
       %% a non-empty value string.
       { 3, {call, ?MODULE, containsValue, [gen_mbox(S), Endpoint, Stream, MapType,
                                            non_empty(gen_val())]}},
       { 5, {call, ?MODULE, remove, [gen_mbox(S), Endpoint, Stream, MapType,
                                     gen_key()]}},
       { 3, {call, ?MODULE, clear, [gen_mbox(S), Endpoint, Stream, MapType]}},
       { 3, {call, ?MODULE, keySet, [gen_mbox(S), Endpoint, Stream, MapType]}},
       { 3, {call, ?MODULE, values, [gen_mbox(S), Endpoint, Stream, MapType]}},
       { 3, {call, ?MODULE, entrySet, [gen_mbox(S), Endpoint, Stream, MapType]}}
      ]).

postcondition(_S, {call,_,reset,[_Mbox, _EP, _RT]}, Ret) ->
    case Ret of
        ["OK"] -> true;
        _Else  -> ?ELSE({got, _Else})
    end;
postcondition(#state{d=D}, {call,_,put,[_Mbox, _EP, _Str, _MT, Key, _Val]}, Ret) ->
    case Ret of
        timeout ->
            false;
        ["OK"] ->
            orddict:find(Key, D) == error;
        ["OK", Prev] ->
            case orddict:find(Key, D) of
                error                  -> Prev == "";
                {ok, V} when V == Prev -> true;
                {ok, _Else}            -> ?ELSE({key, Key, expected, _Else,
                                                 got, Prev})
            end
    end;
postcondition(S, {call,_,get,[_Mbox, _EP, Str, _MT, Key]}, Ret) ->
    %% get's return value is the same as post's return value, so
    %% mock up a put call and share the postcondition() clause.
    postcondition(S, {call,x,put,[_Mbox, _EP, Str, _MT, Key, <<"get_post()">>]}, Ret);
postcondition(#state{d=D}, {call,_,size,[_Mbox, _EP, _Str, _MT]}, Res) ->
    case Res of
        ["OK", SizeStr] ->
            list_to_integer(SizeStr) == length(orddict:to_list(D));
        _Else ->
            ?ELSE({got, _Else})
    end;
postcondition(#state{d=D}, {call,_,isEmpty,[_Mbox, _EP, _Str, _MT]}, Res) ->
    case Res of
        ["OK", Bool] ->
            list_to_atom(Bool) == orddict:is_empty(D);
        _Else ->
            ?ELSE({got, _Else})
    end;
postcondition(#state{d=D}, {call,_,containsKey,[_Mbox, _EP, _Str, _MT, Key]}, Res) ->
    case Res of
        ["OK", Bool] ->
            list_to_atom(Bool) == orddict:is_key(Key, D);
        _Else ->
            ?ELSE({got, _Else})
    end;
postcondition(#state{d=D}, {call,_,containsValue,[_Mbox, _EP, _Str, _MT, Value]}, Res) ->
    case Res of
        ["OK", Bool] ->
            Val_in_d = case [V || {_K, V} <- orddict:to_list(D),
                                  V == Value] of
                           [] -> false;
                           _  -> true
                       end,
            list_to_atom(Bool) == Val_in_d;
        _Else ->
            ?ELSE({got, _Else})
    end;
postcondition(S, {call,_,remove,[_Mbox, _EP, Str, _MT, Key]}, Ret) ->
    %% remove's return value is the same as post's return value, so
    %% mock up a put call and share put_post().
    postcondition(S, {call,x,put,[_Mbox, _EP, Str, _MT, Key, <<"remove_post()">>]}, Ret);
postcondition(_S, {call,_,clear,[_Mbox, _EP, _Str, _MT]}, ["OK"]) ->
    true;
postcondition(#state{d=D}, {call,_,keySet,[_Mbox, _EP, _Str, _MT]}, Ret) ->
    case Ret of
        ["OK", Java_toString] ->
            Ks = split_on_comma(Java_toString),
            lists:sort(Ks) == lists:sort([K || {K,_V} <- orddict:to_list(D)]);
        _Else ->
            ?ELSE({got, _Else})
    end;
postcondition(#state{d=D}, {call,_,values,[_Mbox, _EP, _Str, _MT]}, Ret) ->
    case Ret of
        ["OK", Java_toString] ->
            Vs = split_on_comma(Java_toString),
            %% Our ASCII protocol can't tell us the difference between
            %% an empty list and a list of length one that contains an
            %% empty string.
            lists:sort(Vs) == lists:sort([V || {_K,V} <- orddict:to_list(D),
                                               V /= ""])
    end;
postcondition(#state{d=D}, {call,_,entrySet,[_Mbox, _EP, _Str, _MT]}, Ret) ->
    case Ret of
        ["OK", Java_toString] ->
            Ps = split_on_comma(Java_toString),
            KVs = [begin
                       case string:tokens(Pair, "=") of
                           [K, V] -> {K, V};
                           [K]    -> {K, ""}
                       end
                   end || Pair <- Ps],
            lists:sort(KVs) == lists:sort(orddict:to_list(D));
        _Else ->
            ?ELSE({got, _Else})
    end.

next_state(S, _V, {call,_,reset,[_Mbox, _EP, ReplicationType]}) ->
    S#state{reset_p=true, replication_type=ReplicationType};
next_state(S=#state{d=D}, _V, {call,_,put,[_Mbox, _EP, _Str, _MT, Key, Val]}) ->
    S#state{d=orddict:store(Key, Val, D)};
next_state(S=#state{d=D}, _V, {call,_,remove,[_Mbox, _EP, _Str, _MT, Key]}) ->
    S#state{d=orddict:erase(Key, D)};
next_state(S, _V, {call,_,clear,[_Mbox, _EP, _Str, _MT]}) ->
    S#state{d=orddict:new()};
next_state(S, _V, _NoSideEffectCall) ->
    S.

%%%%

%% Quick human-friendly versions of RPC invocations to Java Land(tm).
%% Useful for developer exploration at the Erlang shell.

reset() ->
    apply(?MODULE, reset, ?QUICK_MBOX ++ [chain_replication]).

reset(RT) ->
    apply(?MODULE, reset, ?QUICK_MBOX ++ [RT]).

reboot() ->
    apply(?MODULE, reboot, ?QUICK_MBOX).

put(Stream, MapType, Key, Val) ->
    apply(?MODULE, put, ?QUICK_MBOX ++ [Stream, MapType, Key, Val]).

get(Stream, MapType, Key) ->
    apply(?MODULE, get, ?QUICK_MBOX ++ [Stream, MapType, Key]).

size(Stream, MapType) ->
    apply(?MODULE, size, ?QUICK_MBOX ++ [Stream, MapType]).

isEmpty(Stream, MapType) ->
    apply(?MODULE, isEmpty, ?QUICK_MBOX ++ [Stream, MapType]).

containsKey(Stream, MapType, Key) ->
    apply(?MODULE, containsKey, ?QUICK_MBOX ++ [Stream, MapType, Key]).

containsValue(Stream, MapType, Value) ->
    apply(?MODULE, containsValue, ?QUICK_MBOX ++ [Stream, MapType, Value]).

remove(Stream, MapType, Key) ->
    apply(?MODULE, remove, ?QUICK_MBOX ++ [Stream, MapType, Key]).

%% %% putAll() can't be tested because our ASCII protocol can't represent
%% %% the needed map.

clear(Stream, MapType) ->
    apply(?MODULE, clear, ?QUICK_MBOX ++ [Stream, MapType]).

keySet(Stream, MapType) ->
    apply(?MODULE, keySet, ?QUICK_MBOX ++ [Stream, MapType]).

values(Stream, MapType) ->
    apply(?MODULE, values, ?QUICK_MBOX ++ [Stream, MapType]).

entrySet(Stream, MapType) ->
    apply(?MODULE, entrySet, ?QUICK_MBOX ++ [Stream, MapType]).

reset(Mbox, Endpoint, ReplicationType) ->
    %% Reset the LayoutServer.
    ["OK"] = layout_qc:reset(),

    case ReplicationType of
        chain_replication ->
            ok;
        replex ->
            %% Create & commit a Replex-style layout.
            EP = lists:flatten(io_lib:format("\"~s\"", [Endpoint])),
            LayoutJSON = "{\"layoutServers\":[" ++ EP ++ "],\"sequencers\":[" ++ EP ++ "],\"segments\":[{\"replicationMode\":\"REPLEX\",\"start\":0,\"end\":-1,\"stripes\":[{\"logServers\":[" ++ EP ++ "]}],\"replexes\":[{\"logServers\":[" ++ EP ++ "]}]}],\"epoch\":0}",
            ["OK"] = layout_qc:commit(0, 1, LayoutJSON)
    end,

    %% Reset the SequencerServer and LogUnitServers.
    Res = rpc(Mbox, reset, Endpoint),

    Res.

reboot(Mbox, Endpoint) ->
    io:format(user, "r", []),
    rpc(Mbox, reboot, Endpoint).

put(Mbox, Endpoint, Stream, MapType, Key, Val) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["put", Key ++ "," ++ Val]).

get(Mbox, Endpoint, Stream, MapType, Key) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["get", Key]).

size(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["size"]).

isEmpty(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["isEmpty"]).

containsKey(Mbox, Endpoint, Stream, MapType, Key) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["containsKey", Key]).

containsValue(Mbox, Endpoint, Stream, MapType, Value) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["containsValue", Value]).

remove(Mbox, Endpoint, Stream, MapType, Key) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["remove", Key]).

%% %% putAll() can't be tested because our ASCII protocol can't represent
%% %% the needed map.

clear(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["clear"]).

keySet(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["keySet"]).

values(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["values"]).

entrySet(Mbox, Endpoint, Stream, MapType) ->
    rpc(Mbox, Endpoint, Stream, MapType, ["entrySet"]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% cmd_prop() and cmd_prop_parallel() for use by TravisCI

cmd_prop() ->
    cmd_inner(proper:quickcheck(prop())).

cmd_prop_parallel() ->
    cmd_inner(proper:quickcheck(prop_parallel())).

cmd_inner(true) ->
    erlang:halt(0);
cmd_inner(Else) ->
    io:format("\nError: ~p\n", [Else]),
    Counter = proper:counterexample(),
    io:format("\nCounterexample:\n~p\n", [Counter]),
    io:format("\nCounterexample (pretty):\n~s\n\n", [pf(Counter)]),
    erlang:halt(1).

%% NOTE: Do not mix replex & chain_replication tests in the same SUT.
%%       I don't fully understand why ... some bit of state isn't
%%       getting reset correctly.

warn_about(ReplType) ->
    case get({?MODULE,warn_about}) of
        X when X /= undefined, X /= ReplType ->
            io:format(user, "\n\nWARNING: Do not mix replex & chain_replication tests in the same SUT without a full restart.\n\n", []);
        _ ->
            ok
    end,
    put({?MODULE,warn_about}, ReplType).

prop() ->
    prop(chain_replication, smrmap, 1).

prop(ReplType, MapType, MoreCmds) ->
    prop(ReplType, MapType, MoreCmds, qc_java:local_mboxes(), qc_java:local_endpoint()).

prop(ReplType, MapType, MoreCmds, Mboxes, Endpoint)
  when (ReplType == chain_replication orelse ReplType == replex)
       andalso
       (MapType == smrmap orelse MapType == fgmap) ->
    warn_about(ReplType),
    %% Hmmmm, more_commands() doesn't appear to work correctly with Proper.
    ?FORALL(Cmds, more_commands(MoreCmds,
                                commands(?MODULE,
                                         initial_state(ReplType, MapType,
                                                       Mboxes, Endpoint))),
            begin
                {H, S_or_Hs, Res} = run_commands(?MODULE, Cmds),
                aggregate(command_names(Cmds),
                measure(
                  cmds_length,
                  ?COMMANDS_LENGTH(Cmds),
                ?PRETTY_FAIL(
                  ?MODULE, Cmds, H,S_or_Hs,Res,
                  begin
                      Res == ok
                  end
                )))
            end).

prop_parallel() ->
    prop_parallel(chain_replication, smrmap, 1).

prop_parallel(ReplType, MapType, MoreCmds) ->
    prop_parallel(ReplType, MapType, MoreCmds, qc_java:local_mboxes(), qc_java:local_endpoint()).

prop_parallel(ReplType, MapType, MoreCmds, Mboxes, Endpoint)
  when (ReplType == chain_replication orelse ReplType == replex)
       andalso
       (MapType == smrmap orelse MapType == fgmap) ->
    warn_about(ReplType),
    AlwaysNum = 2,
    io:format(user, "NOTE: parallel cmds are executed ~w times to try to detect non-determinism\n", [AlwaysNum]),
    ?FORALL(Cmds, more_commands(MoreCmds,
                                parallel_commands(?MODULE,
                                         initial_state(ReplType, MapType,
                                                       Mboxes, Endpoint))),
            ?WRAP_ALWAYS(AlwaysNum,
            begin
                {H, S_or_Hs, Res} = run_parallel_commands(?MODULE, Cmds),
                aggregate(command_names(Cmds),
                measure(
                  cmds_length,
                  ?COMMANDS_LENGTH(Cmds),
                ?PRETTY_FAIL(
                  ?MODULE, Cmds, H,S_or_Hs,Res,
                  begin
                      Res == ok
                      orelse
                      %% If we witness a bug that we know about, we'll
                      %% ignore the failure and let QuickCheck try
                      %% another test.
                      res_contains_known_exceptions(S_or_Hs)
                  end
                )))
            end)).

%% pretty print

pp(Term) ->
    io:format("~s\n", [pf(Term)]).

%% pretty format

pf(Term) ->
    Mod = ?MODULE,
    try
        lists:flatten(qc_java:pp_format(qc_java:pretty_filter(Term, Mod), Mod))
    catch
        _:_ ->
            lists:flatten(io_lib:format("~p", [Term]))
    end.

pretty_filter(S = #state{}) ->
    S#state{reg_names='...omitted...'};
pretty_filter({set,{var,Var},{call,?MODULE,Func,[{A1,_},_A2|Args]}}) ->
    RT = list_to_atom("runtime" ++ [lists:last(atom_to_list(A1))]),
    case Args of
        [] ->
            #exec{step=Var, func=Func, args=[RT]};
        [_Stream, _Type|Rest] ->
            #exec{step=Var, func=Func,
                  args=[RT,
                        %% {stream,Stream},
                        [pretty_filter(Term) || Term <- Rest]]};
        _ ->
            #exec{step=Var, func=Func,
                  args=[RT,qc_java:pretty_filter(Args, ?MODULE)]}
    end;
pretty_filter([]) ->
    %% Approximate "" -> '', because otherwise Erlang formatting will convert
    %% the zero length string "" -> [].
     '';
pretty_filter(Term) ->
    Term.

res_contains_known_exceptions(_S_or_Hs) ->
    false.

split_on_comma(String) ->
    string:tokens(string:strip(string:strip(String, left, $[), right, $]), ", ").

java_ify(L) ->
    [begin
         MapType = case MapT of smrmap -> "SMRMap";
                                fgmap  -> "FGMap"
                   end,
         RunTimeNum = lists:last(atom_to_list(Cmdlet)) - $0,
         io:format("CorfuRuntime runtime~w = getRuntimeAndConnect(endpoint);\n", [RunTimeNum]),
         io:format("Map<String,String> testMap~w = runtime~w.getObjectsView().build().setType(~s.class).setStreamName(streamName).open();\n", [RunTimeNum, RunTimeNum, MapType]),
         ArgsStr = string:strip(string:strip(re:replace(lists:flatten(io_lib:format("~p", [Args])), "[ \n]", "", [global,multiline,{return,list}]), left, $[), right, $]),
         io:format("String var~w = testMap~w.~s(~s);\n", [V, RunTimeNum, Func, ArgsStr]),
         io:format("\n")
     end || {set,{var,V},{call,map_qc,Func,
                          [{Cmdlet,_},_EP,_Stream,MapT|Args]}} <- L].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

rpc(Mbox, reset, Endpoint) ->
    AllArgs = ["corfu_smrobject", "reset", Endpoint],
    qc_java:rpc_call(Mbox, AllArgs, ?TIMEOUT);
rpc(Mbox, reboot, Endpoint) ->
    AllArgs = ["corfu_smrobject", "reboot", Endpoint],
    qc_java:rpc_call(Mbox, AllArgs, ?TIMEOUT).

rpc({_RegName, _NodeName} = Mbox, Endpoint, Stream, MapType, Args) ->
    Class = if MapType == smrmap -> "org.corfudb.runtime.collections.SMRMap";
               MapType == fgmap  -> "org.corfudb.runtime.collections.FGMap"
            end,
    AllArgs = ["corfu_smrobject", "-c", Endpoint,
               %% -p = --quickcheck-ap-prefix
               "-p", lists:flatten(io_lib:format("~w", [Mbox])),
               "-s", integer_to_list(Stream),
               Class]
              ++ Args,
    qc_java:rpc_call(Mbox, AllArgs, ?TIMEOUT).
